<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-09-30 Tue 17:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Advent Of Code 2022 - Day 13: Distress Signal</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/light.css">        <link rel="stylesheet" href="/css/style.css"> 	        <!-- Icons -->       <link rel="apple-touch-icon" sizes="180x180" href="/img/icons/apple-touch-icon.png">       <link rel="icon" type="image/png" sizes="32x32" href="/img/icons/favicon-32x32.png">       <link rel="icon" type="image/png" sizes="16x16" href="/img/icons/favicon-16x16.png">       <link rel="manifest" href="/img/icons/site.webmanifest">       <link rel="mask-icon" href="/img/icons/safari-pinned-tab.svg" color="#5bbad5">       <link rel="shortcut icon" href="/img/icons/favicon.ico">       <meta name="msapplication-TileColor" content="#da532c">       <meta name="msapplication-config" content="/img/icons/browserconfig.xml">       <meta name="theme-color" content="#ffffff">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<header id="preamble" class="status">
<aside>
  <a href="/">
    <img class="avatar" src="/img/photo.jpg"/>
  </a>
  <section>
    I help people solve hard problems. This often involves a computer.
  </section>

  <nav class="nav">
    <ul>
      <li>
        <a class="nav-item" href="/">Home</a>
        |
      </li>
      <li>
        <a class="nav-item" href="/posts/">Blog</a>
        |
      </li>

      <li>
        <a class="nav-item" href="/talks/">Talks</a>
        |
      </li>

      <li>
        <a class="nav-item" href="https://stackoverflow.com/users/2700399/bart-van-nierop">
          <i class="fab fa-stack-overflow"></i>
        </a>
        |
      </li>

      <li>
        <a class="nav-item" href="https://github.com/bvnierop">
          <i class="fab fa-github-square"></i>
        </a>
        |
      </li>

      <li>
        <a class="nav-item" href="https://www.linkedin.com/in/bart-van-nierop/">
          <i class="fab fa-linkedin"></i>
        </a>
      </li>

    </ul>
  </nav>
</aside>
</header>
<main id="content">
<header>
<h1 class="title">Advent Of Code 2022 - Day 13: Distress Signal</h1>
<p class="subtitle">Dec 13, 2022</p>
</header><p>
It's December. Time for snow, slippery roads, hot chocolate and cozy fire
places. Also time for <a href="https://adventofcode.com/2022">Advent of Code</a>. An advent calendar with small, daily
programming puzzles, growing progressively more difficult.
</p>

<p>
Every year I participate in a programming language I did not use for Advent of
Code before, in order to learn new ways of doing things and to challenge
myself. This year, that language is F#.
</p>

<div id="outline-container-org2ef2b29" class="outline-2">
<h2 id="org2ef2b29">Day 13: Distress Signal</h2>
<div class="outline-text-2" id="text-org2ef2b29">
<p>
Summary: Given a list of pairs of <i>packets</i>, where each <i>packet</i> is a list where
each element is either an integer or another list, determine how many pairs are
in the correct order.
</p>

<p>
Example input:
</p>

<div class="org-src-container">
<pre class="src src-txt">[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]
</pre>
</div>

<p>
To determine which packets comes first, compare each element from left to
right. If both elements are integers then the smallest comes first. If one
element is a list and the other an integer, convert the integer to a
single-element list and compare the lists. Finally if both elements are lists,
compare their numbers from left to right. If one list runs out of numbers before
a difference is found, that list comes first.
</p>

<p>
Read the full problem statement <a href="https://adventofcode.com/2022/day/13">here</a>.
</p>

<p>
Today we're helped greatly by the choice of language. The logic for comparing
lists already exists in F#. We can prove that by putting some tests in a REPL.
</p>

<div class="org-src-container">
<pre class="src src-fsharp">compare [1] [1]
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">int</span> = 0

compare [1] [1;2]
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">int</span> = -1

compare [1] [2]
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">int</span> = -1
</pre>
</div>

<p>
F# being a statically typed language, we cannot mix integers and lists of
integers. Therefore we need to introduce a type that can do that for us.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">type</span> <span class="org-type">Expr</span>&lt;'a&gt; = Value <span class="org-keyword">of</span> 'a <span class="org-fsharp-ui-operator">|</span> List <span class="org-keyword">of</span> Expr&lt;'a&gt; list
</pre>
</div>

<p>
This in itself handles most cases. The one case that isn't handled here is when
a value is compared to a list. To make that work we have to implement our own,
custom comparison function. F# has support for that.
</p>

<p>
We tag our type with <code>CustomComparison</code> and <code>CustomEquality</code> attributes and
implement the required functions. The only one that matters is <code>compare</code>, which
compares the two instances. If both are values or both are lists, it defers to
the built-in compare. Otherwise it recurses, boxing the value in a list.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">type</span> <span class="org-type">Expr</span>&lt;'a <span class="org-keyword">when</span> 'a: <span class="org-type">comparison&gt;</span> =
    Value <span class="org-keyword">of</span> 'a <span class="org-fsharp-ui-operator">|</span> List <span class="org-keyword">of</span> 'a Expr list

    <span class="org-keyword">static</span> <span class="org-keyword">member</span> <span class="org-function-name">compare</span> a b =
        <span class="org-keyword">match</span> (a, b) <span class="org-keyword">with</span>
        <span class="org-fsharp-ui-operator">|</span> (Value aVal, Value bVal) -&gt; Operators.compare aVal bVal
        <span class="org-fsharp-ui-operator">|</span> (List aList, List bList) -&gt; Operators.compare aList bList
        <span class="org-fsharp-ui-operator">|</span> (List _, Value _) -&gt; compare a (List [b])
        <span class="org-fsharp-ui-operator">|</span> (Value _, List _) -&gt; compare (List [a]) b
</pre>
</div>

<p>
To parse the input we could keep track of brackets and depth and all that jazz,
or we could write a recursive parser in FParsec.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-variable-name">pExpr</span>, <span class="org-variable-name">pExprImpl</span> = createParserForwardedToRef()
<span class="org-keyword">let</span> <span class="org-variable-name">pList</span> = between (pchar <span class="org-string">'['</span>) (pchar <span class="org-string">']'</span>) (sepBy pExpr (pchar <span class="org-string">','</span>)) <span class="org-fsharp-ui-generic">|&gt;&gt;</span> List
<span class="org-keyword">let</span> <span class="org-variable-name">pValue</span> = pint32 <span class="org-fsharp-ui-generic">|&gt;&gt;</span> Value
pExprImpl.Value &lt;- pValue <span class="org-fsharp-ui-generic">&lt;|&gt;</span> pList

<span class="org-keyword">let</span> <span class="org-variable-name">parseList</span> = List.map (parseOrDie pExpr)
</pre>
</div>

<p>
The interesting part here is on the first line. <code>pExpr</code> is a parser that parses
an expression. It defers its implementation to <code>pExprImpl</code>, which is a
reference, meaning we can change it. Since <code>pList</code> parses a list matches
<code>pExpr</code>, and <code>pExpr</code> is either a <code>pValue</code> or a <code>pList</code> this is our way around
that cyclic dependency.
</p>

<p>
A small helper will check if two packets are in the correct order. It compares
the list of packets against the sorted list. We can use built-ins because of our
custom compare function.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-function-name">inRightOrder</span> <span class="org-variable-name">expressions</span> = expressions = List.sort expressions
</pre>
</div>

<p>
With all that in place, solving the problem is trivial, though a bit more code
than I'd like.
</p>

<p>
We group the input in lists of two packets. We parse each list and immediately
check if it's in the right order, storing only that.
</p>

<p>
We need to sum the 1-based indices of those pairs of packets that are in the
correct order, so the rest of the code does that. It adds indices (which are 0
based), removes the pairs that are in the wrong order, drops the booleans,
increments the indices and finally sums them.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-function-name">solve1</span> (<span class="org-variable-name">input</span>: <span class="org-type">string list</span>) =
    input <span class="org-fsharp-ui-operator">|&gt;</span> List.splitOnExclusive String.isNullOrEmpty
    <span class="org-fsharp-ui-operator">|&gt;</span> List.map (parseList &gt;&gt; rightOrder)
    <span class="org-fsharp-ui-operator">|&gt;</span> List.indexed
    <span class="org-fsharp-ui-operator">|&gt;</span> List.filter (<span class="org-keyword">fun</span> (<span class="org-variable-name">_</span>, <span class="org-variable-name">b</span>) -&gt; b)
    <span class="org-fsharp-ui-operator">|&gt;</span> List.map (fst &gt;&gt; ((+) 1))
    <span class="org-fsharp-ui-operator">|&gt;</span> List.sum
</pre>
</div>
</div>
</div>

<div id="outline-container-org5c3eb8b" class="outline-2">
<h2 id="org5c3eb8b">Part 2</h2>
<div class="outline-text-2" id="text-org5c3eb8b">
<p>
Summary: Part 2 asks us to add two <i>marker</i> packets to the input and find the
markers when all packets are in the correct order.
</p>

<p>
Since <code>List.sort</code> works for us, this is remarkably trivial, although the
function ends up being slightly larger than part 1.
</p>

<p>
We create our markers. Then we take the input, remove the empty lines and parse
it. Add the markers and sort the list.
</p>

<p>
Once again we need indices, so we add the 0-based index to the list. Select only
the markers from the remaining list, select only the indices, increment them and
finally multiply them.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-function-name">solve2</span> (<span class="org-variable-name">input</span>: <span class="org-type">string list</span>) =
    <span class="org-keyword">let</span> <span class="org-variable-name">dividers</span> = [<span class="org-string">"[[2]]"</span>;<span class="org-string">"[[6]]"</span>] <span class="org-fsharp-ui-operator">|&gt;</span> parseList
    input <span class="org-fsharp-ui-operator">|&gt;</span> List.reject String.isNullOrEmpty
    <span class="org-fsharp-ui-operator">|&gt;</span> parseList
    <span class="org-fsharp-ui-operator">|&gt;</span> List.append dividers
    <span class="org-fsharp-ui-operator">|&gt;</span> List.sort
    <span class="org-fsharp-ui-operator">|&gt;</span> List.indexed
    <span class="org-fsharp-ui-operator">|&gt;</span> List.filter (<span class="org-keyword">fun</span> (<span class="org-variable-name">_</span>, <span class="org-variable-name">e</span>) -&gt; List.contains e dividers)
    <span class="org-fsharp-ui-operator">|&gt;</span> List.map (fst &gt;&gt; ((+) 1))
    <span class="org-fsharp-ui-operator">|&gt;</span> List.fold (*) 1
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d82f5d" class="outline-2">
<h2 id="org6d82f5d">Improvements</h2>
<div class="outline-text-2" id="text-org6d82f5d">
<p>
I've noticed that in many posts the improvements are pretty much the same. I
hack together a solution using <code>for</code>-loops and mutation and then refactor the
mutation away, changing the <code>for</code>-loop into a <code>fold</code> or a <code>scan</code>.
</p>

<p>
In most cases I can also extract the solution to part 1, make one or two things
slightly configurable and pass those in both parts.
</p>

<p>
I'll leave these kinds of improvements out of this section for now and just
immediately describe them as they've ended up after refactoring. If I learn
something <i>new</i> then it will still end up in this section.
</p>
</div>
</div>

<div id="outline-container-orgfe63da6" class="outline-2">
<h2 id="orgfe63da6">Reflection</h2>
<div class="outline-text-2" id="text-orgfe63da6">
<p>
Reading today's problem I had flashbacks to yesteryear's problem with snailfish
numbers. A problem that took me many hours to complete. Thankfully it was a lot
easier.
</p>

<p>
I ended up being helped a lot by the language, which already implements list
comparison in the same way that this problem expects it, making the rest of the
implementation trivial.
</p>

<p>
The full code for the day is on <a href="https://github.com/bvnierop/advent-of-code-fsharp/blob/main/src/AdventOfCode.Solutions/2022/Day13.fs">GitHub</a>.
</p>
</div>
</div>
</main>
<footer id="postamble" class="status">
&copy; 2021-2025 Bart van Nierop. All rights reserved.

<script data-goatcounter="https://bvnierop.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</footer>
</body>
</html>
